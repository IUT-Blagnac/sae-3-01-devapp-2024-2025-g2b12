= SAE S2.02 - Rapport d'Évaluation (Phase 2)
:compat-mode!:
:toc:
:toc-title: Table des matières
:toclevels: 4
:icons: font
:stem: latexmath

// paramères relatif à GitHub
ifdef::env-github[]
:note-caption: :information_source:
:stem: latexmath
endif::[]


// PAGE DE GARDE
---

// logos de l'IUT de Blagnac et de l'université Jean Jaurès de Toulouse
image::./res/img-iut-blagnac.png[IUT de Blagnac, 200]
image::./res/img-univ-tlse2.jpg[Université Toulouse II - Jean Jaurès (31), 200]

---

*Étudiant* +
Victor Jockin

*Enseignants* +
Jean-Michel Bruel +
Yahn Formanczak

*Formation* +
BUT Informatique +
1ère Année +
Promotion 2023-2024 +

*Établissement* +
IUT de Blagnac, +
Université Toulouse II – Jean Jaurès (31)

---


== *Avant-propos*

Madame, Monsieur,

Le présent document présente des imperfections et des incohérences que je n'ai pas eu le courage de corriger. Aussi, certaines parties manquent cruellement d'explications et de détails. Je dois avouer qu'après avoir travaillé quatre jours durant sans interruption sur la rédaction de ce rapport, je ne pense pas avoir l'énergie de l'améliorer davantage. Je vous prie de bien vouloir m'excuser pour cet aveu d'échec, mais je ne tiens pas à rendre cette SAE davantage en retard (je suis déjà trop en retard). J'espère que le contenu est à peu près de qualité, j'ai fait de mon mieux pour qu'il le soit un peu.

En vous remerciant pour votre attention et votre compréhension,

*_Victor Jockin_*


== *1. Présentation des outils d'évaluation*

=== 1.1 Outils et librairies

==== *_1.1.1 Outils de mesure de la consommation électrique du processeur d'une machine_*

===== _Power Monitor pour macOS_

====== Présentation

*_Power Monitor pour macOS_* est un outil de ligne de commande permettant la lecture de la consommation électrique du processeur d'une machine via l'outil *_Powermetrics_*. Il fournit la consommation électrique du processeur de la machine chaque seconde.

Cet outil interviendra dans le cadre de l'évaluation de la consommation électrique du processeur par les algorithmes de compression concourant dans la catégorie *_Sobriété_*.

====== Utilisation
Cette librairie est contenue dans un unique fichier de script bash. Celui-ci est exécutable en ligne de commande.

====== Mise en oeuvre
Afin de mesurer la consommation électrique du processeur par les différents algorithmes évalés, cet outil doit être exécuté en parallèle de l'exécution de programmes de test. Ces derniers ont pour but d'exécuter des tests, d'une durée de plusieurs secondes, impliquant les algorithmes de compression évalués, afin de déterminer leur consommation électrique moyenne en processeur.


==== *_1.1.2 Outils de mesure de la qualité d'un algorithme_*

===== _Codacy_

====== Présentation

Codacy est un outil de revue de code automatisé aidant les développeurs à faciliter la révision du code et à améliorer la qualité des programmes développés.

Cet outil interviendra dans le cadre de l'évaluation de la qualité des algorithmes de compression concourant dans les catégories *_Efficacité_* et *_Sobriété_*.

====== Indicateurs considérés

ISSUES (PROBLÈMES)::
    Problèmes relatifs à un fichier / code.

COMPLEXITY (COMPLEXITÉ)::
    Complexité d'un fichier / code.

DUPLICATION (DUPLICATION)::
    Nombre de lignes de code dupliquées dans un même fichier.


=== 1.2 Tests unitaires

Cette section présente les tests unitaires en langages `Java`, `C` et `Python` utilisés dans le cadre de la vérification du bon fonctionnement des algorithmes de compression à évaluer.

==== *_1.2.1 Tests unitaires en langage Java (Tests JUnit)_*

[source,java]
----
package iut.sae.algo ;

import org.junit.Test ;
import junit.framework.TestCase ;

public class AlgoTest extends TestCase
{
	/*
	 * RLE("")       = ""
	 * RLE("abc")    = "1a1b1c"
	 * RLE("abbccc") = "1a2b3c"
	 * RLE("aaabaa") = "3a1b2a"
	 * RLE("aAa")    = "1a1A1a"
	 */
	@Test
	public void testRLE()
	{
		assertEquals("", Algo.RLE("") ) ;

		assertEquals("1a1b1c", Algo.RLE("abc")) ;
		assertEquals("1a2b3c", Algo.RLE("abbccc")) ;
		assertEquals("3a1b2a", Algo.RLE("aaabaa")) ;
		assertEquals("1a1A1a", Algo.RLE("aAa")) ;
	}

	/*
	 * RLE(str, 1) = RLE(str)
	 * RLE(str, 3) = RLE(RLE(RLE(str)))
	 */
	@Test
	public void testRLERecursif()
	{
		try
		{
			assertEquals("", Algo.RLE("", 1)) ;
			assertEquals("", Algo.RLE("", 3)) ;
			
			assertEquals("1a1b1c", Algo.RLE("abc", 1)) ;
			assertEquals("1a2b3c", Algo.RLE("abbccc", 1)) ;
			assertEquals("3a1b2a", Algo.RLE("aaabaa", 1)) ;
			assertEquals("1a1A1a", Algo.RLE("aAa", 1)) ;

			assertEquals("111a111b111c", (Algo.RLE("abc", 2))) ;
			assertEquals("311a311b311c", (Algo.RLE("abc", 3))) ;

			String saeIte20 = "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211S1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211 1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211l1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211g1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211o" ;
			assertEquals(saeIte20, Algo.RLE("SAE Algo", 20)) ;
		}
		catch(Exception e)
		{
			fail("Exception inatendue") ;
		}
	}

	/*
	 * unRLE(RLE(str))	= str
	 *
	 * unRLE("") 		= ""
	 * unRLE("1a1b1c") 	= "abc"
	 * unRLE("1a2b3c") 	= "abbccc"
	 * unRLE("3a1b2a") 	= "aaabaa"
	 * unRLE("1a1A1a") 	= "aAa"
	 */
	@Test
	public void testUnRLE()
	{
		try
		{
			assertEquals("", Algo.unRLE("")) ;

			assertEquals("abc", Algo.unRLE("1a1b1c")) ;
			assertEquals("abbccc", Algo.unRLE("1a2b3c")) ;
			assertEquals("aaabaa", Algo.unRLE("3a1b2a")) ;
			assertEquals("aAa", Algo.unRLE("1a1A1a")) ;
		}
		catch(Exception e)
		{
			fail("Exception inatendue") ;
		}
	}
	
	@Test
	public void testUnRLERecursif()
	{
		try
		{
			assertEquals("", Algo.unRLE("", 1)) ;
			assertEquals("", Algo.unRLE("", 3)) ;
			
			assertEquals("abc", Algo.unRLE("1a1b1c", 1)) ;
			assertEquals("abbccc", Algo.unRLE("1a2b3c", 1)) ;
			assertEquals("aaabaa", Algo.unRLE("3a1b2a", 1)) ;
			assertEquals("aAa", Algo.unRLE("1a1A1a", 1)) ;

			assertEquals("abc", (Algo.unRLE("111a111b111c", 2))) ;
			assertEquals("abc", (Algo.unRLE("311a311b311c", 3))) ;
		}
		catch(Exception e)
		{
			fail("Exception inatendue") ;
		}
	}
}
----

==== *_1.2.2 Tests unitaires en langage C_*

[source,c]
----
#include <stdio.h>
#include <string.h>

// [ import du programme à tester ]


/**
 * Reproduit le comportement de la méthode java {assertEquals()} du framework JUnit.
 * 
 * @param expected  IN :    Pointeur vers la chaîne de caractères attendue.
 * @param actual    IN :    Pointeur vers la chaîne de caractères à comparer.
 * 
 * @return 1 si les chaînes de caractères sont identiques, 0 sinon.
 */
int assertEquals(char *expected, char *actual)
{
    // déclaration des variables
    int assertion = 0 ;         // proposition testée : les deux chaînes en paramètres sont-elles identiques ?

    // traitement
    if (strcmp(expected, actual) == 0)
    {
        // les deux chaînes comparées sont identiques
        assertion = 1 ;
    }
    return assertion ;
}

/**
 * Fonction de test
 * ------------------------
 * RLE("")       = ""
 * RLE("abc")    = "1a1b1c"
 * RLE("abbccc") = "1a2b3c"
 * RLE("aaabaa") = "3a1b2a"
 * RLE("aAa")    = "1a1A1a"
 */
void testRLE()
{
    assertEquals("", RLE("")) ;

	assertEquals("1a1b1c", RLE("abc")) ;
	assertEquals("1a2b3c", RLE("abbccc")) ;
	assertEquals("3a1b2a", RLE("aaabaa")) ;
	assertEquals("1a1A1a", RLE("aAa")) ;

    // message console
    printf("(1) Tests RLE() réussis.\n") ;
}

/**
 * Fonction de test
 * --------------------------------
 * RLE(str, 1) = RLE(str)
 * RLE(str, 3) = RLE(RLE(RLE(str)))
 */
void testRLERecursif()
{
	assertEquals("", RLERecursif("", 1)) ;
	assertEquals("", RLERecursif("", 3)) ;
			
	assertEquals("1a1b1c", RLERecursif("abc", 1)) ;
	assertEquals("1a2b3c", RLERecursif("abbccc", 1)) ;
	assertEquals("3a1b2a", RLERecursif("aaabaa", 1)) ;
	assertEquals("1a1A1a", RLERecursif("aAa", 1)) ;

	assertEquals("111a111b111c", (RLERecursif("abc", 2))) ;
	assertEquals("311a311b311c", (RLERecursif("abc", 3))) ;

	char saeIte20[] = "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211S1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211 1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211l1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211g1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211o" ;
	assertEquals(saeIte20, RLERecursif("SAE Algo", 20)) ;

    // message console
    printf("(2) Tests RLERecursif() réussis.\n") ;
}

/**
 * Fonction de test
 * ---------------------------
 * unRLE(RLE(str))  = str
 *
 * unRLE("")        = ""
 * unRLE("1a1b1c")  = "abc"
 * unRLE("1a2b3c")  = "abbccc"
 * unRLE("3a1b2a")  = "aaabaa"
 * unRLE("1a1A1a")  = "aAa"
 */
void testUnRLE()
{
    assertEquals("", unRLE("")) ;
			
	assertEquals("abc", unRLE("1a1b1c")) ;
	assertEquals("abbccc", unRLE("1a2b3c")) ;
	assertEquals("aaabaa", unRLE("3a1b2a")) ;
	assertEquals("aAa", unRLE("1a1A1a")) ;

    // message console
    printf("(3) Tests unRLE() réussis.\n") ;
}

/**
 * Fonction de test
 */
void testUnRLERecursif()
{
	assertEquals("", unRLERecursif("", 1)) ;
	assertEquals("", unRLERecursif("", 3)) ;
			
	assertEquals("abc", unRLERecursif("1a1b1c", 1)) ;
	assertEquals("abbccc", unRLERecursif("1a2b3c", 1)) ;
	assertEquals("aaabaa", unRLERecursif("3a1b2a", 1)) ;
	assertEquals("aAa", unRLERecursif("1a1A1a", 1)) ;

	assertEquals("abc", (unRLERecursif("111a111b111c", 2))) ;
	assertEquals("abc", (unRLERecursif("311a311b311c", 3))) ;

    // message console
    printf("(4) Tests unRLERecursif() réussi.\n") ;
}

int main(void)
{
    // Programme principal
    // -------------------

    printf("EXÉCUTION DES TESTS UNITAIRES\n") ;
    printf("-----------------------------\n") ;

    // exécution des tests unitaires
    testRLE() ;
    testRLERecursif() ;
    testUnRLE() ;
    testUnRLERecursif() ;

    // code de retour (succès)
    return 0 ;
}
----

==== *_1.2.3 Tests unitaires en langage Python_*

[source,python]
----
import unittest
import sys
import os

# paramétrage de l'accès aux fichiers python (extension .py)
# situés sous le répertoire {src/main/python}
sys.path.append(
    os.path.abspath(
        os.path.join(os.path.dirname(__file__), '../../main/python')
    )
)

# import des fonctions à tester
from a import *


'''
-------------------
Classe de test
-------------------
Fonctions testées :
• RLE()
• RLERecursif()
• unRLE()
• unRLERecursif()
-------------------
'''
class AlgoTest(unittest.TestCase) :

    # Fonction de test
    # ------------------------
    # RLE("")       = ""
    # RLE("abc")    = "1a1b1c"
    # RLE("abbccc") = "1a2b3c"
    # RLE("aaabaa") = "3a1b2a"
    # RLE("aAa")    = "1a1A1a"
    # ------------------------
    def testRLE(self) :
        self.assertEqual("", RLE(""))
        
        self.assertEqual("1a1b1c", RLE("abc"))
        self.assertEqual("1a2b3c", RLE("abbccc"))
        self.assertEqual("3a1b2a", RLE("aaabaa"))
        self.assertEqual("1a1A1a", RLE("aAa"))
    

    # Fonction de test
    # ----------------------------------------
    # RLERecursif(str, 1) = RLE(str)
	# RLERecursif(str, 3) = RLE(RLE(RLE(str)))
    # ----------------------------------------
    def testRLERecursif(self) :
        try :
            self.assertEqual("", RLERecursif("", 1))
            self.assertEqual("", RLERecursif("", 3))

            self.assertEqual("1a1b1c", RLERecursif("abc", 1))
            self.assertEqual("1a2b3c", RLERecursif("abbccc", 1))
            self.assertEqual("3a1b2a", RLERecursif("aaabaa", 1))
            self.assertEqual("1a1A1a", RLERecursif("aAa", 1))

            self.assertEqual("111a111b111c", (RLERecursif("abc", 2)))
            self.assertEqual("311a311b311c", (RLERecursif("abc", 3)))

            saeIte20 = "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211S1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211E1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211 1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211A1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211l1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211g1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123113221231231121113213221231221132221222112112322211o"
            self.assertEqual(saeIte20, RLERecursif("SAE Algo", 20))
        except Exception as e :
            self.fail("Exception inatendue : " + str(e))


    # Fonction de test
    # ----------------------------
	# unRLE(RLE(str))   = str
	# unRLE("")         = ""
	# unRLE("1a1b1c")   = "abc"
	# unRLE("1a2b3c")   = "abbccc"
	# unRLE("3a1b2a")   = "aaabaa"
	# unRLE("1a1A1a")   = "aAa"
    # ----------------------------
    def testUnRLE(self) :
        try :
            self.assertEqual("", unRLE(""))
            self.assertEqual("abc", unRLE("1a1b1c"))
            self.assertEqual("abbccc", unRLE("1a2b3c"))
            self.assertEqual("aaabaa", unRLE("3a1b2a"))
            self.assertEqual("aAa", unRLE("1a1A1a"))
        except Exception as e :
            return "Exception inattendue"
    

    # Fonction de test
    def testUnRLERecursif(self) :
        try :
            self.assertEqual("", unRLERecursif("", 1))
            self.assertEqual("", unRLERecursif("", 3))
                        
            self.assertEqual("abc", unRLERecursif("1a1b1c", 1))
            self.assertEqual("abbccc", unRLERecursif("1a2b3c", 1))
            self.assertEqual("aaabaa", unRLERecursif("3a1b2a", 1))
            self.assertEqual("aAa", unRLERecursif("1a1A1a", 1))

            self.assertEqual("abc", (unRLERecursif("111a111b111c", 2)))
            self.assertEqual("abc", (unRLERecursif("311a311b311c", 3)))
        except Exception as e :
            self.fail("Exception inatendue : " + str(e))


# Exécution des tests
# -------------------
TESTS_UNITAIRES = unittest.TestLoader().loadTestsFromTestCase(AlgoTest)
RESULTAT        = unittest.TextTestRunner(verbosity=2).run(TESTS_UNITAIRES)
print("\n-----\n")
print("Tests run:       " + str(RESULTAT.testsRun))
print("Tests succeeded: " + str(RESULTAT.testsRun - len(RESULTAT.failures)))
print("Tests failed:    " + str(len(RESULTAT.failures)))
----

=== 1.3 Programmes utilitaires

==== *_1.3.1 Générateur de chaînes de caractères aléatoires._*
[source,java]
----
package iut.sae.utilitaire ;

import java.util.Random ;

/**
 * Utilitaire : Générateur de chaînes de caractères aléatoires.
 * @author Victor Jockin
 */
public class RandomStringGenerator
{
    private static final char[] TAB_CARACTERES =
    {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
    } ;

    public static String genererChaineAleatoireSimple(int pfLongueurChaine)
    {
        // déclaration et initialisation des variables
        Random alea                     = new Random() ;                        // gestion de l'aléatoire
        StringBuilder chaineAleatoire   = new StringBuilder(pfLongueurChaine) ; // chaîne aléatoire (retournée)

        for (int i = 0 ; i < pfLongueurChaine ; i++)
        {
            // ajout en fin de chaîne d'un caractère sélectionné aléatoirement
            // parmi la liste des caractères disponibles
            chaineAleatoire.append(TAB_CARACTERES[alea.nextInt(TAB_CARACTERES.length)]) ;
        }

        // renvoi de la chaîne aléatoire construite
        return chaineAleatoire.toString() ;
    }

    public static String genererChaineAleatoireAvecRepetitionsForcees(int pfLongueurChaine)
    {
        // déclaration et initialisation des variables
        Random alea                     = new Random() ;                        // gestion de l'aléatoire
        StringBuilder chaineAleatoire   = new StringBuilder(pfLongueurChaine) ; // chaîne aléatoire (retournée)
        int i                           = 0 ;                                   // compteur de boucle

        // construction de la chaîne aléatoire
        while (i < pfLongueurChaine)
        {
            // initialisation du caractère aléatoire courant
            // (sélection parmi la liste des caractères disponibles)
            char caractereAleatoire = TAB_CARACTERES[alea.nextInt(TAB_CARACTERES.length)] ;

            if (alea.nextInt(20) == 0)
            {
                // "forçage" de la répétition du caractère aléatoire courant (au maximum 10 fois)
                int nbRepetitions = alea.nextInt(8) + 2 ; // nombre de répétition compris entre 2 et 10
                for (int k = 0 ; k < nbRepetitions && i < pfLongueurChaine ; k++)
                {
                    // ajout en fin de chaîne du caractère sélectionné
                    chaineAleatoire.append(caractereAleatoire) ;
                    i++ ;
                }
            }
            else
            {
                // ajout en fin de chaîne du caractère sélectionné
                chaineAleatoire.append(caractereAleatoire) ;
                i++ ;
            }
        }

        // renvoi de la chaîne aléatoire construite
        return chaineAleatoire.toString() ;
    }
}
----


=== 1.4 Programmes de mesure

==== *_1.4.1 Mesure du temps d'exécution d'un algorithme_*

===== 1.4.1.1 Catégorie *_Simplicité_*

====== Chaîne de test
[source,txt]
----
"""
HORACE
Vous n’ignorez pas qu’en ces occasions
Un secret éventé rompt nos prétentions.
Je vous avouerai donc avec pleine franchise,
Qu’ici d’une beauté mon âme s’est éprise :
Mes petits soins d’abord ont eu tant de succès,
Que je me suis chez elle ouvert un doux accès ;
Et sans trop me vanter, ni lui faire une injure,
Mes affaires y sont en fort bonne posture.

ARNOLPHE, riant.
Et c’est ?

HORACE, lui montrant le logis d’Agnès.
Un jeune objet qui loge en ce logis,
Dont vous voyez d’ici que les murs sont rougis,
Simple à la vérité, par l’erreur sans seconde
D’un homme qui la cache au commerce du monde,
Mais qui dans l’ignorance où l’on veut l’asservir,
Fait briller des attraits capables de ravir,
Un air tout engageant, je ne sais quoi de tendre,
Dont il n’est point de cœur qui se puisse défendre :
Mais, peut-être, il n’est pas que vous n’ayez bien vu
Ce jeune astre d’amour de tant d’attraits pourvu :
C’est [ ? ] qu’on l’appelle.

ARNOLPHE, à part.
Ah ! je crève.
"""
----

====== Programme de mesure en langage Java
_Extrait du corps de la méthode `main()` d'une classe `Java` contenant les méthodes de compression et de décompression à tester._

[source,java]
----
public class MesuresSimplicite
{
    // [ insérer ici les méthodes de compression à tester ]

    public static void main(String[] args) throws Exception
    {
        // déclaration de la chaîne de caractères de test
        String moliere = "..." ;

        // enregistrement du temps initial en millisecondes
        long tempsInitial = System.nanoTime() ;

        // exécution de la méthode à évaluer
        RLE(moliere, 10) ;
        
        // enregistrement du temps final en millisecondes
        long tempsFinal = System.nanoTime() ;

        // calcul du temps d'exécution de la méthode
        double tempsExecution = (tempsFinal - tempsInitial) / 1_000_000.0 ;

        // affichage du temps d'exécution obtenu
        System.out.printf("Temps d'exécution : %.3f ms%n", tempsExecution) ;
    }
}
----

====== Programme de mesure en langage C
_Extrait du corps de la méthode `main()` d'un code en langage `C` contenant les méthodes de compression et de décompression à tester._

[source,c]
----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// [ imports de fichiers ]


// [ insérer ici les méthodes de compression à tester ]


int main()
{
    // déclaration de la chaîne de caractères de test
    char *moliere = "..." ;

    // déclaration des variables chargées de l'enregistrement des temps
    struct timespec tempsInitial, tempsFinal ;

    // enregistrement du temps initial en nanosecondes
    clock_gettime(CLOCK_MONOTONIC, &tempsInitial) ;

    // exécution de la méthode à évaluer
    RLERecursif(moliere, 10) ;

    // enregistrement du temps final en nanosecondes
    clock_gettime(CLOCK_MONOTONIC, &tempsFinal) ;

    // calcul du temps d'exécution de la méthode
    double tempsExecution = (tempsFinal.tv_sec - tempsInitial.tv_sec) * 1000.0 + (tempsFinal.tv_nsec - tempsInitial.tv_nsec) / 1000000.0 ;

    // affichage du temps d'exécution obtenu
    printf("Temps d'exécution : %.3f ms\n", tempsExecution) ;

    return 0 ;
}
----

====== Programme de mesure en langage Python
_Extrait du corps d'un code en langage `Python` contenant les méthodes de compression et de décompression à tester._

[source,python]
----


# [ insérer ici les méthodes de compression à tester ]


import time

# déclaration de la chaîne de caractères de test
moliere = "..."

# enregistrement du temps initial en nanosecondes
temps_initial = time.time_ns()

# exécution de la méthode à évaluer
RLERecursif(moliere, 10)

# enregistrement du temps final en nanosecondes
temps_final = time.time_ns()

# calcul du temps d'exécution de la méthode
temps_execution = (temps_final - temps_initial) / 1_000_000.0

# affichage du temps d'exécution obtenu
print(f"Temps d'exécution : {temps_execution:.3f} ms")
----

===== 1.4.1.2 Catégorie *_Efficacité_*

====== Chaînes de test
[source,txt]
----
Chaînes de test générées aléatoirement : Catégorie EFFICACITÉ
-------------------------------------------------------------


* * * Chaînes Simples * * *

[Chaîne vide]
""

[Chaîne de 10 caractères]
"XML5MJTXOV"

[Chaîne de 100 caractères]
"PZNHK2WOHE5BNOV7MJQDVLCD7PAIIYQWAACOM4SHWFE47FY1KEZTFJV9RC0LYBM2671PUC20HXBTLFSBNYE1G7UHHDPGSQZKQJ7L"

[Chaîne de 1000 caractères]
"OZTA943U6AXU22QD9UY3B8ZMX6BXOGQSL5JE1PTS278MG734VPPRZM3QNJTGUCL799N7JT8E28W4OJU4KSEI4RZZ9Q4ZPW9PY5ZM7TCR4U6HR9BPT86CHK1YBE2Y69LIOV0TXRU1GZ6SHYZUQ69Y5KVIM9GX36AX8K1TTA1HZGJTRGX46SUM20SGE5I113UEXCKNK71YCK2OZUPYERBQB7HCIOOWGPBFWBNIODVY09RD698T1VM57TW270D49GOQXXNQAHQYBIE8PZXTW383C3V542E8IN2NN5SZAYQL82NUAK0AIDKO1GEIAEB4HY07Y5TD9OJCGVPA6J1ZOK49IXFKHKO889MIC7W9L0IR6Z97U05XTN6KZL0CJGTD8PGW61FLN5M5ISZBG87NIVNRBCCIBML26AY4UHB38WBG6O3IUAJIBTJXS3C5F1TU9EXVWSRU2WEDFSK2EMEYVF1E5LU6BJTRSCW17RHQJAUNF0SGI96YU2JM2NSHCML0XLSTWCBVLK7SYCD15NX79Y7174MPMWKXUF4CQSMEADDCK088MY358VI4WK2JSJ77T6KA6RUPWEHXFRODV0EKE57D5KMFFKIGDPSY84NITPQPEJ7W3XKJ00SY6STSQZLYP48HYTOOZUC0FVFLP09EH3NE02OVDS0CZ31IJ9IJCSOOMYXL3HZZ9C99LSXCIRU22ZEQ9NTNRR9NCT5YKDC4EP2766EII4006S8P091KRCNHTP628ZJDH8EL3ZIUO7UEB1DJPXTV6AE7OOXKV0KGLBW5CJQ8PVG95Q7JC83UFDJXT7FK1JK7O3LDYRLJKYAVGSE202HVUUDN9E5YACQIYCP8BQJ8YUJIFYC3I7FTY4W44HYUMOE60IG6WKO2QOCD4KFR1J7OD4C59GT1PA0BP513QETRA5DCM3EYLANHEHEAXYD6JF9PMHMFVWP9E7TFMZT7CCHY1W9MFPRS06CJFMHR5GKWFRIJ2YDVJGZSUKME"


* * * Chaînes Avec Répétitions Forcées * * *

[Chaîne de 10 caractères]
"QM4MKZHESF"

[Chaîne de 100 caractères]
"D9OHHHHHHHHPCGGGGM5I8D16GAAIQ4KALQRWD17MOX188P5T12KF5U2IDUFN3AMMMMRBL406UMEMXE97VFJNHB7AHBF79QLIJXDJ"

[Chaîne de 1000 caractères]
"ZUNQGG8KOTYQC0VT3LA767DDW8K5T6KNDCULGNG5PNWZGEIX69WG13DFMM9FVH6BIX3BESCCXRIZ22V0XZT0GRVZV8EI8J1IKVLFZG09BGTTTTTTLLLLLL1UPVCK0W7VNE07PB7RI2F1ZA1JNZZNLBY0777QOBIB01K5553LAL11TUUUUUUUUU8JJJJJJJJJ4E9KG545H1XID0LSIKU4EUSNPTDIQ0WVUR2UB1WGATER9OLVVVVV71QZCB539B9EFYNUK1VLIQKE1M6FBBBBBBBBB8LLQ605W0FKDVYYH0GR6PS48YAJMDYUV2SO2AJQVSMADJHBUDOU8IXMNDYLTTWKG5DUUWF1ZXQVL0QYYYYYYWJWEAPR8OHN99PU9LUNANFOKZSJ999999ADWW9M5DDDDDHACLOX21QZH6WOGOR1FIIP3FVD3BYF7DBG1SEV0YYYYN4JT1CVP1MC815ZZZZZZZZWJNXAZMTJ23KQ92YS3SIJHZG1888888X6UNSO7QOORFX2S699LQPJHHHHHHHVUL2LDIEXTGLWGB7LMRC9GQZ3ILR0409CSEG622222DMWWWWWWWWM0H2L70RRTFNFZI7UVZHANMLOEBDMDDDDQXA4KEFRP222OK9JMHBBBBBBBBNQX24X2MKC8TS07DOAFH4JJ8HLQWKKP3I9MSUAAWIKCXXB7EXHRCYFOI1LH99C3Q6WDHGDRWWWWWW3XPW20PIFXPUWW7V4ZA9JD401YYQ699MMMHBPMNLTMSJASRPPB4QK1OL9N5C2GHCR6IE3VHOFX6PCPPPPPPKSGKXBP6CMPPPPPPONCQF68HOJ7J3KVIS9LLLCYQQQ1WRX1NTE7GBKKY1RVY0MASPXJYM00UUUUUUDSBSSSSSSQQQQQQQ361Y533X6O9KFSSSSSSSSS0MBMMMMMMMMMFNDLPF9176OOOOOOOQF9RRPNTO44MDRR1NIGMZZZZZZZZZIRWWWWHJFD6NNJDOWY35D"
----

====== Programme de mesure en langage Java
_Extrait du corps de la méthode `main()` d'une classe `Java` contenant les méthodes de compression et de décompression à tester._

[source,java]
----
public class MesuresEfficacite
{
    // [ insérer ici les méthodes de compression à tester ]

    public static void main(String[] args) throws Exception
    {
        // Tests Catégorie Efficacité
        // --------------------------

        // déclaration et initialisation des chaînes de test
        String chaineVide                       = "" ;
        String chaineAleatoireSimple10          = "XML5MJTXOV" ;
        String chaineAleatoireSimple100         = "PZNHK2WOHE5BNOV7MJQDVLCD7PAIIYQWAACOM4SHWFE47FY1KEZTFJV9RC0LYBM2671PUC20HXBTLFSBNYE1G7UHHDPGSQZKQJ7L" ;
        String chaineAleatoireSimple1000        = "OZTA943U6AXU22QD9UY3B8ZMX6BXOGQSL5JE1PTS278MG734VPPRZM3QNJTGUCL799N7JT8E28W4OJU4KSEI4RZZ9Q4ZPW9PY5ZM7TCR4U6HR9BPT86CHK1YBE2Y69LIOV0TXRU1GZ6SHYZUQ69Y5KVIM9GX36AX8K1TTA1HZGJTRGX46SUM20SGE5I113UEXCKNK71YCK2OZUPYERBQB7HCIOOWGPBFWBNIODVY09RD698T1VM57TW270D49GOQXXNQAHQYBIE8PZXTW383C3V542E8IN2NN5SZAYQL82NUAK0AIDKO1GEIAEB4HY07Y5TD9OJCGVPA6J1ZOK49IXFKHKO889MIC7W9L0IR6Z97U05XTN6KZL0CJGTD8PGW61FLN5M5ISZBG87NIVNRBCCIBML26AY4UHB38WBG6O3IUAJIBTJXS3C5F1TU9EXVWSRU2WEDFSK2EMEYVF1E5LU6BJTRSCW17RHQJAUNF0SGI96YU2JM2NSHCML0XLSTWCBVLK7SYCD15NX79Y7174MPMWKXUF4CQSMEADDCK088MY358VI4WK2JSJ77T6KA6RUPWEHXFRODV0EKE57D5KMFFKIGDPSY84NITPQPEJ7W3XKJ00SY6STSQZLYP48HYTOOZUC0FVFLP09EH3NE02OVDS0CZ31IJ9IJCSOOMYXL3HZZ9C99LSXCIRU22ZEQ9NTNRR9NCT5YKDC4EP2766EII4006S8P091KRCNHTP628ZJDH8EL3ZIUO7UEB1DJPXTV6AE7OOXKV0KGLBW5CJQ8PVG95Q7JC83UFDJXT7FK1JK7O3LDYRLJKYAVGSE202HVUUDN9E5YACQIYCP8BQJ8YUJIFYC3I7FTY4W44HYUMOE60IG6WKO2QOCD4KFR1J7OD4C59GT1PA0BP513QETRA5DCM3EYLANHEHEAXYD6JF9PMHMFVWP9E7TFMZT7CCHY1W9MFPRS06CJFMHR5GKWFRIJ2YDVJGZSUKME" ;
        String chaineAleatoireRepetitions10     = "QM4MKZHESF" ;
        String chaineAleatoireRepetitions100    = "D9OHHHHHHHHPCGGGGM5I8D16GAAIQ4KALQRWD17MOX188P5T12KF5U2IDUFN3AMMMMRBL406UMEMXE97VFJNHB7AHBF79QLIJXDJ" ;
        String chaineAleatoireRepetitions1000   = "ZUNQGG8KOTYQC0VT3LA767DDW8K5T6KNDCULGNG5PNWZGEIX69WG13DFMM9FVH6BIX3BESCCXRIZ22V0XZT0GRVZV8EI8J1IKVLFZG09BGTTTTTTLLLLLL1UPVCK0W7VNE07PB7RI2F1ZA1JNZZNLBY0777QOBIB01K5553LAL11TUUUUUUUUU8JJJJJJJJJ4E9KG545H1XID0LSIKU4EUSNPTDIQ0WVUR2UB1WGATER9OLVVVVV71QZCB539B9EFYNUK1VLIQKE1M6FBBBBBBBBB8LLQ605W0FKDVYYH0GR6PS48YAJMDYUV2SO2AJQVSMADJHBUDOU8IXMNDYLTTWKG5DUUWF1ZXQVL0QYYYYYYWJWEAPR8OHN99PU9LUNANFOKZSJ999999ADWW9M5DDDDDHACLOX21QZH6WOGOR1FIIP3FVD3BYF7DBG1SEV0YYYYN4JT1CVP1MC815ZZZZZZZZWJNXAZMTJ23KQ92YS3SIJHZG1888888X6UNSO7QOORFX2S699LQPJHHHHHHHVUL2LDIEXTGLWGB7LMRC9GQZ3ILR0409CSEG622222DMWWWWWWWWM0H2L70RRTFNFZI7UVZHANMLOEBDMDDDDQXA4KEFRP222OK9JMHBBBBBBBBNQX24X2MKC8TS07DOAFH4JJ8HLQWKKP3I9MSUAAWIKCXXB7EXHRCYFOI1LH99C3Q6WDHGDRWWWWWW3XPW20PIFXPUWW7V4ZA9JD401YYQ699MMMHBPMNLTMSJASRPPB4QK1OL9N5C2GHCR6IE3VHOFX6PCPPPPPPKSGKXBP6CMPPPPPPONCQF68HOJ7J3KVIS9LLLCYQQQ1WRX1NTE7GBKKY1RVY0MASPXJYM00UUUUUUDSBSSSSSSQQQQQQQ361Y533X6O9KFSSSSSSSSS0MBMMMMMMMMMFNDLPF9176OOOOOOOQF9RRPNTO44MDRR1NIGMZZZZZZZZZIRWWWWHJFD6NNJDOWY35D" ;


        // Paramétrage des variables de test
        // ---------------------------------

        // initialisation de la Chaîne de test courante
        String[] tabChainesDeTest = new String[7] ;
        tabChainesDeTest[0] = chaineVide ;
        tabChainesDeTest[1] = chaineAleatoireSimple10 ;
        tabChainesDeTest[2] = chaineAleatoireSimple100 ;
        tabChainesDeTest[3] = chaineAleatoireSimple1000 ;
        tabChainesDeTest[4] = chaineAleatoireRepetitions10 ;
        tabChainesDeTest[5] = chaineAleatoireRepetitions100 ;
        tabChainesDeTest[6] = chaineAleatoireRepetitions1000 ;

        // initialisation du niveau de compression
        int[] tabNbIterations = new int[4] ;
        tabNbIterations[0] = 1 ;
        tabNbIterations[1] = 10 ;
        tabNbIterations[2] = 25 ;
        tabNbIterations[3] = 50 ;

        for (int iNbIt = 0 ; iNbIt < tabNbIterations.length ; iNbIt++)
        {
            int nbIterations = tabNbIterations[iNbIt] ;

            for (int iString = 0 ; iString < tabChainesDeTest.length ; iString++)
            {
                if (iString > 3)
                {
                    System.out.println("\nChaînes Avec Répétitions Forcées") ;
                }
                else
                {
                    System.out.println("\nChaînes Simples") ;
                }

                String chaineDeTest = tabChainesDeTest[iString] ;

                // initialisation du nombre d'exécution du test
                int nbIterationsTest ;
                if (nbIterations > 25)
                {
                    nbIterationsTest = 1 ; // POUR ÉVITER QUE CE SOIT TROP LONG
                }
                else
                {
                    nbIterationsTest = 100 ;
                }
                System.out.println("(NbIt Test : " + nbIterationsTest + ")") ;

                
                // Exécution du test
                // -----------------

                double[] tabTempsExecution = new double[nbIterationsTest] ;

                for (int i = 0 ; i < nbIterationsTest ; i++)
                {
                    // enregistrement du temps initial en millisecondes
                    long tempsInitial = System.nanoTime() ;

                    // exécution de la méthode à évaluer
                    try
                    {
                        if (!(iString == 3 && nbIterations == 50)) // POUR ÉVITER LA SURCHARGE DE LA MÉMOIRE PROVOQUANT UNE INTERRUPTION DU PROGRAMME
                        {
                            RLE(chaineDeTest, nbIterations) ;    
                        }
                    }
                    catch (Exception e)
                    {
                        System.out.println(e) ;
                    }
                    
                    // enregistrement du temps final en millisecondes
                    long tempsFinal = System.nanoTime() ;

                    // calcul du temps d'exécution de la méthode
                    double tempsExecution = (tempsFinal - tempsInitial) / 1_000_000.0 ;
                    tabTempsExecution[i] = tempsExecution ;

                    // affichage du temps d'exécution obtenu
                    //System.out.printf("Temps d'exécution : %.3f ms%n", tempsExecution) ;
                }

                // calcul de la moyenne des temps d'exécution
                double moyenne = 0 ;
                for (int k = 0 ; k < tabTempsExecution.length ; k++)
                {
                    moyenne = moyenne + tabTempsExecution[k] ;
                }
                moyenne = moyenne / tabTempsExecution.length ;
            
                // affichage de la moyenne des temps d'exécution
                System.out.printf("NbChars : " + chaineDeTest.length() + " | NbIt : " + nbIterations + " | Temps d'exécution moyen : %.3f ms%n", moyenne) ;
            }
        }
    }
}
----

==== *_1.4.2 Mesure de la consommation électrique du processeur par un algorithme_*

[source,java]
----
package iut.sae.calcul.sobriete ;

import iut.sae.algo.Algo ;

import java.io.BufferedReader ;
import java.io.IOException ;
import java.io.InputStreamReader ;

/**
 * Classe de calcul : Détermine la consommation électrique du processeur (CPU).
 * @author Victor Jockin
 */
public class CalculConsomCPU
{
    // unité : W | Watt(s)

    public static void main(String[] args) throws Exception
    {
        // déclaration d'un tableau de Processus de taille 1
        final Process[] processus = new Process[1] ;

        // thread d'exécution du script (.sh) de mesure de la cosnommation électrique du CPU
        Thread scriptThread = new Thread(
            () ->
            {
                try
                {
                    ProcessBuilder processBuilder = new ProcessBuilder("sudo", "bash", "src/main/java/iut/sae/calcul/sobriete/joular/powermonitor-intel.sh") ;
                    processBuilder.redirectErrorStream(true) ;
                    processus[0] = processBuilder.start() ;

                    // lecture des lignes du script
                    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(processus[0].getInputStream())) ;
                    String ligne ;
                    while ((ligne = bufferedReader.readLine()) != null)
                    {
                        System.out.println(ligne) ;
                    }

                    // attente avant fin d'exécution
                    processus[0].waitFor() ;
                }
                catch (IOException ioe)
                {
                    ioe.printStackTrace() ;
                }
                catch (InterruptedException ie)
                {
                    ie.printStackTrace() ;
                }
            }
        ) ;

        // lancement du thread d'exécution du script
        scriptThread.start() ;

        // (pseudo) attente de saisie du mot de passe
        try
        {
            Thread.sleep(10000) ;
        }
        catch (InterruptedException ie)
        {
            ie.printStackTrace() ;
        }

        // message console
        System.out.println("* * * Début Programme de Test * * *") ;

        // exécution du programme de test JAVA
        Algo.main(args) ;                       // CLASSE CONTENANT LES MÉTHODES DE COMPRESSION À TESTER AINSI QUE LES TESTS À RÉALISER

        // message console
        System.out.println("* * * Fin Programme de Test * * *") ;

        // attente d'une seconde avant interruption du script
        try
        {
            Thread.sleep(1000) ;
        }
        catch (InterruptedException e)
        {
            e.printStackTrace() ;
        }

        // interruption du script une fois que le programme de test est temriné
        if (processus[0] != null && processus[0].isAlive())
        {
            processus[0].destroy() ;
        }
    }
}
----

==== *_1.4.3 Mesure de la consommation mémoire d'un algorithme_*

[source,java]
----
package iut.sae.calcul.sobriete ;

/**
 * Classe de calcul : Détermine la consommation électrique du processeur (CPU).
 * @author Victor Jockin
 */
public class CalculConsomMemoire
{
    // déclaration des attributs
    Runtime runtime ;           // permet d'intéragir avec l'environnement d'exécution

    // Constructeur par défaut : 1 paramètre
    public CalculConsomMemoire ( )
    {
        this.runtime = Runtime.getRuntime() ;
    }

    // Accesseur (get) : Donne la mémoire totale disponible pour l'application
    public int getMemoireTotaleDisponible()
    {
        this.runtime = Runtime.getRuntime() ;
        return (int) (this.runtime.totalMemory() / 1024) ;
    }

    // Accesseur (get) : Donne la mémoire libre de la mémoire totale disponible
    public int getMemoireLibre()
    {
        this.runtime = Runtime.getRuntime() ;
        return (int) (this.runtime.freeMemory() / 1024) ;
    }

    // Accesseur (get) : Donne la mémoire maximale utilisable par l'application
    public int getMemoireMaximaleUtilisable()
    {
        this.runtime = Runtime.getRuntime() ;
        return (int) (this.runtime.maxMemory() / 1024) ;
    }

    // Accesseur (get) : Donne l'espace mémoire occupé par l'algorithme au cours de son exécution
    public int getMemoireOccupe()
    {
        return this.getMemoireTotaleDisponible() - this.getMemoireLibre() ;
    }
}
----

[source,java]
----
package iut.sae.calcul.sobriete ;

// import iut.sae.algo.AlgoException ;
import iut.sae.utilitaire.RandomStringGenerator ;

public class MesureConsomMemoire
{
    public static String RLE(String in)
    {
        // Code de la méthode de compression RLE
        // ...

        // relevé de la consommation mémoire de l'algorithme
        mesurerConsommationMemoire() ;

        return null ; // normalement, renvoi de la chaîne compressée
    }

    public static void mesurerConsommationMemoire()
    {
        CalculConsomMemoire calculConsomMemoire = new CalculConsomMemoire() ;
        System.out.println("Mémoire Totale Disponible :   " + calculConsomMemoire.getMemoireTotaleDisponible() + " Ko") ;
        System.out.println("Mémoire Libre :               " + calculConsomMemoire.getMemoireLibre() + " Ko") ;
        System.out.println("Mémoire Maximale Utilisable : " + calculConsomMemoire.getMemoireMaximaleUtilisable() + " Ko") ;
        System.out.println("Mémoire Occupée :             " + calculConsomMemoire.getMemoireOccupe() + " Ko") ;
    }

    public static void main(String[] args) throws Exception
    {
        // Tests Catégorie Sobriété
        // ------------------------

        // initialisation des chaînes de test
        String chaineVide                   = "" ;
        String chaineAleatoireSimple10      = RandomStringGenerator.genererChaineAleatoireSimple(10) ;
        String chaineAleatoireSimple50      = RandomStringGenerator.genererChaineAleatoireSimple(50) ;
        String chaineAleatoireSimple100     = RandomStringGenerator.genererChaineAleatoireSimple(100) ;
        String chaineAleatoireSimple500     = RandomStringGenerator.genererChaineAleatoireSimple(500) ;
        String chaineAleatoireSimple1000    = RandomStringGenerator.genererChaineAleatoireSimple(1000) ;

        // stockage des chaînes de test dans un tableau
        String[] tabChainesDeTest = new String[6] ;
        tabChainesDeTest[0] = chaineVide ;
        tabChainesDeTest[1] = chaineAleatoireSimple10 ;
        tabChainesDeTest[2] = chaineAleatoireSimple50 ;
        tabChainesDeTest[3] = chaineAleatoireSimple100 ;
        tabChainesDeTest[4] = chaineAleatoireSimple500 ;
        tabChainesDeTest[5] = chaineAleatoireSimple1000 ;

        // réalisation des tests
        for (int i = 0 ; i < tabChainesDeTest.length ; i++)
        {
            System.out.println("Longueur de chaîne : " + tabChainesDeTest[i].length()) ;
            RLE(tabChainesDeTest[i]) ;
            System.out.println("") ;
        }
    }
}
----




== *2. Évaluation des algorithmes*

=== 2.1 Algorithmes évalués

Dans le tableau ci-dessous, les algorithmes à évaluer sont regroupés par langage (`Java` / `C` / `Python`), puis par catégorie concourue (*Simplicité* / *Efficacité* / *Sobriété*).

// définition des liens et alias
:17simplicite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/17simplicite.java
:22simplicite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/22simplicite.java
:36simplicite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/36simplicite.java
:18efficacite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/18efficacite.java
:21efficacite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/21efficacite.java
:57efficacite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/57efficacite.java
:63efficacite_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/63efficacite.java
:12sobriete_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/12sobriete.java
:25sobriete_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/25sobriete.java
:58sobriete_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/58sobriete.java
:66sobriete_java: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/java/66sobriete.java
:61simplicite_c: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/c/61simplicite.c
:49simplicite_py: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/py/49simplicite.py
:35efficacite_py: https://github.com/IUT-Blagnac/sae2024-2-02-victorjockin/tree/main/data/algorithmes/evaluation/py/35efficacite.py

|===
| *NUMÉRO*     | *PROGRAMME*                            | *LANGAGE* | *CATÉGORIE*
| 17[[Algo17]] | {17simplicite_java}[17simplicite.java] | `Java`    | Simplicité
| 22[[Algo22]] | {22simplicite_java}[22simplicite.java] | `Java`    | Simplicité
| 36[[Algo36]] | {36simplicite_java}[36simplicite.java] | `Java`    | Simplicité
| 18[[Algo18]] | {18efficacite_java}[18efficacite.java] | `Java`    | Efficacité
| 21[[Algo21]] | {21efficacite_java}[21efficacite.java] | `Java`    | Efficacité
| 57[[Algo57]] | {57efficacite_java}[57efficacite.java] | `Java`    | Efficacité
| 63[[Algo63]] | {63efficacite_java}[63efficacite.java] | `Java`    | Efficacité
| 12[[Algo12]] | {12sobriete_java}[12sobriete.java]     | `Java`    | Sobriété
| 25[[Algo25]] | {25sobriete_java}[25sobriete.java]     | `Java`    | Sobriété
| 58[[Algo58]] | {58sobriete_java}[58sobriete.java]     | `Java`    | Sobriété
| 66[[Algo66]] | {66sobriete_java}[66sobriete.java]     | `Java`    | Sobriété
| 61[[Algo61]] | {61simplicite_c}[61simplicite.c]       | `C`       | Simplicité
| 49[[Algo49]] | {49simplicite_py}[49simplicite.py]     | `Python`  | Simplicité
| 35[[Algo35]] | {35efficacite_py}[35efficacite.py]     | `Python`  | Efficacité
|===

NOTE: Les numéros de traitement (colonne `NUMÉRO`) permettent l'identification des différents programmes évalués.

=== 2.2 Barème appliqué

|===
4+^| *BARÈME D'ÉVALUATION DES ALGORITHMES DE COMPRESSION DE TYPE `RLE`*
4+|
2+| *MODE D'ÉVALUATION* 2+| Notation sur 20 points.
4+|
| *ID* | *CRITÈRE D'ÉVALUATION* 2+| *NOTE ATTRIBUÉE*
| CE.1 | Le programme ne fonctionne pas. 2+| 5 pts
| CE.2 | Le programme fonctionne mais ne passe pas les tests initialement fournis. 2+| 10 pts
| CE.3 | Le programme passe tous les tests initialement fournis. 2+| 18 pts
| CE.4 | Le programme passe les tests supplémentaires (plus complets). 2+| 20 pts
4+|
| *ID* | *CRITÈRE DE SANCTION* 2+| *SANCTION APPLIQUÉE*
| CS.1 | Le programme ne compile pas. | Note finale divisée par 2 | *_HORS CONCOURS_*
| CS.2 | Le programme ne respecte pas la contrainte portant sur les méthodes du package `java.util` (programmes concourant dans la catégorie *Efficacité* uniquemnet). | -1 pts | *_HORS CONCOURS_*
| CS.3 | Le programme ne respecte pas la règle d'anonymat. | -1 pts |
| CS.4 | Les commentaires du code comportent plus de 5 fautes d'orthographe et / ou de syntaxe. | -0.5 pts |
4+|
| *ID* | *CRITÈRE D'OBTENTION DE POINTS BONUS* 2+| *BONUS APPLIQUÉ*
| B.1 | Le programme comporte des commentaires clairs et utiles. | +2 pts | _S'applique uniquement si la note finale après sanctions (le cas échéant) est inférieure ou égale à 18 / 20._
4+|
4+^| *Remarque*
4+| Aucune.
|===

=== 2.3 Attribution des notes

|===
.2+| *NUMÉRO* .2+| *LANGAGE* .2+| *CATÉGORIE* 4+| *ÉVALUATION* 4+| *SANCTIONS* | *BONUS* .2+| *NOTE FINALE*
| CE.1 | CE.2 | CE.3 | CE.4 | CS.1 | CS.2 | CS.3 | CS.4 | B.1
| <<Algo17,17>> | `Java`   | Simplicité | -- | -- | -- | 20 | -- | -- | -- | -- | -- | 20.00 / 20.00
| <<Algo22,22>> | `Java`   | Simplicité | -- | -- | 18 | -- | -- | -- | -- |-0.5| +2 | 19.50 / 20.00
| <<Algo36,36>> | `Java`   | Simplicité | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo18,18>> | `Java`   | Efficacité | -- | 10 | -- | -- | -- | -- | -- | -- | -- | 10.00 / 20.00
| <<Algo21,21>> | `Java`   | Efficacité | -- | -- | -- | 20 | -- | -- | -- | -- | -- | 20.00 / 20.00
| <<Algo57,57>> | `Java`   | Efficacité | -- | 10 | -- | -- | -- | -- | -- | -- | +2 | 12.00 / 20.00
| <<Algo63,63>> | `Java`   | Efficacité | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo12,12>> | `Java`   | Sobriété   | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo25,25>> | `Java`   | Sobriété   | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo58,58>> | `Java`   | Sobriété   | -- | -- | -- | 20 | -- | -- | -- | -- | -- | 20.00 / 20.00
| <<Algo66,66>> | `Java`   | Sobriété   | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo61,61>> | `C`      | Simplicité | -- | -- | -- | 20 | -- | -- | -- | -- |(+2)| 20.00 / 20.00
| <<Algo49,49>> | `Python` | Simplicité | -- | -- | 18 | -- | -- | -- | -- | -- | -- | 18.00 / 20.00
| <<Algo35,35>> | `Python` | Efficacité | -- | 10 | -- | -- | -- | -- | -- | -- | -- | 10.00 / 20.00
13+|
13+^| *Remarque*
13+| Les valeurs numériques indiquées correspondent à des notes sur 20 et à des points bonus / malus.
|===


== *3. Classement des algorithmes par catégories*

=== 3.1 Catégorie : Simplicité

==== *_3.1.1 Méthodologie et critères de classement_*

|===
3+^| *CRITÈRES DE CLASSEMENT*
3+^| _CATÉGORIE_ *_SIMPLICITÉ_*
3+|
| *ID* | *CRITÈRE* | *MAXIMUM POINTS ATTRIBUÉS*
3+|
3+^| *_CONTENU_*
| C1 | Le programme comporte une méthode `RLE()`. | 50 pts
| C2 | Le programme comporte une méthode `RLE()` itérative / récursive. | 50 pts
| C3 | Le programme comporte une méthode `unRLE()`. | 50 pts
| C4 | Le programme comporte une méthode `unRLE()` itérative / récursive. | 50 pts
| C5 | Le programme ne définit pas de méthode principale (méthode `main()`). | 20 pts
| C6 | Les signatures des méthodes respectent les règles de nommage imposées (`RLE`, `RLERecursif`, `unRLE`, `unRLERecursif`, ou noms similaires). | 40 pts
2+| _TOTAL POINTS CONTENU_ | _260 pts_
3+|
3+^| *_EXÉCUTION_*
| E1 | Le programme compile et s'exécute. | 100 pts
.2+| E2 | Le temps d'exécution du programme appliqué 10 fois à une chaîne de moins de 1000 caractères est inférieur à 500 ms, soit 0.5 s (méthodes `RLE()` simple et `RLE()` itérative / récursive uniquement). .2+| 10 pts
| _On considère qu'un algorithme est simple et facilement réutilisable si son temps d'exécution est convenable._
2+| _TOTAL POINTS EXÉCUTION_ | _110 pts_
3+|
3+^| *_FONCTIONNEMENT_*
| F1 | Le type de retour des méthodes de compression / décompression est une chaîne de caractères. | 80 pts
| F2 | Le programme produit les résultats attendus. | 150 pts
| F3 | Le programme passe les tests unitaires avec succès. | 100 pts
| F4 | Le programme traite l'ensemble des cas d'erreurs (levées d'exceptions ou aucun plantage). | 50 pts
2+| _TOTAL POINTS FONCTIONNEMENT_ | _380 pts_
3+|
3+^| *_LISIBILITÉ_*
| L1 | Le code est lisible et aéré (sauts de lignes, retours à la ligne, espaces, indentation... etc.). | 50 pts
| L2 | Les noms de variables sont clairs et explicites. | 50 pts
| L3 | Les noms de variables sont uniformisés et cohérents entre eux (même langue, mêmes règles de nommage... etc.). | 25 pts
| L4 | Le programme fourni comporte des commentaires clairs et utiles. | 50 pts
| L5 | Les commentaires sont tous rédigés dans une même langue. | 50 pts
| L6 | Les commentaires sont correctement rédigés (respect de l'orthographe, de la syntaxe et des règles grammaticales). | 25 pts
2+| _TOTAL POINTS LISIBILITÉ_ | _250 pts_
3+|
2+| *_TOTAL POINTS_* | *_1000 pts_*
3+|
3+^| *Remarque*
3+| Les critères de classement décrits ci-dessus s'appliquent uniquement aux algorithmes coucourant dans la catégorie *_Simplicité_*.
|===

==== *_3.1.2 Classement obtenu_*

|===
9+^| *CLASSEMENT*
9+^| _CATÉGORIE_ *_SIMPLICITÉ_*
9+|
| *RANG* .6+| | *NUMÉRO*            | *PROGRAMME*                            | *LANGAGE* .6+| | *TOTAL POINTS* | *NOTE ÉQUIVALENTE* | *NOTE ARRONDIE AU PLUS PROCHE*
| *_1_*       | 61[[AlgoClassmt61]] | {61simplicite_c}[61simplicite.c]       | `C`            | 945 / 1000     | 18.90 / 20.00      | 19.00 / 20.00
| *_2_*       | 17[[AlgoClassmt17]] | {17simplicite_java}[17simplicite.java] | `Java`         | 860 / 1000     | 17.20 / 20.00      | 17.25 / 20.00
| *_3_*       | 22[[AlgoClassmt22]] | {22simplicite_java}[22simplicite.java] | `Java`         | 850 / 1000     | 17.00 / 20.00      | 17.00 / 20.00
| 4           | 49[[AlgoClassmt49]] | {49simplicite_py}[49simplicite.py]     | `Python`       | 815 / 1000     | 16.30 / 20.00      | 16.25 / 20.00
| 5           | 36[[AlgoClassmt36]] | {36simplicite_java}[36simplicite.java] | `Java`         | 800 / 1000     | 16.00 / 20.00      | 16.00 / 20.00
|===

---

|===
20+^| *DÉTAIL DU CLASSEMENT*
20+^| _CATÉGORIE_ *_SIMPLICITÉ_*
20+|
20+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
20+|
.3+| *N°* 18+| *POINTS PAR CRITÈRES DE CLASSEMENT* .3+| *TOTAL POINTS*
6+| CONTENU 2+| EXÉC. 4+| FONCTIONNEMENT 6+| LISIBILITÉ
| C1 | C2 | C3 | C4 | C5 | C6 | E1 | E2 | F1 | F2 | F3 | F4 | L1 | L2 | L3 | L4 | L5 | L6
.2+| <<AlgoClassmt17,17>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 10 | 80 | 150 | 100 | 50 | 45 | 45 | 20 | 0 | 0 | 0 .2+| *860*
6+^| _260_ 2+^| _110_ 4+^| _380_ 6+^| _110_
.2+| <<AlgoClassmt22,22>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 10 | 80 | 150 | 100 | 0 | 15 | 25 | 25 | 20 | 50 | 15 .2+| *850*
6+^| _260_ 2+^| _110_ 4+^| _330_ 6+^| _150_
.2+| <<AlgoClassmt36,36>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 10 | 80 | 150 | 100 | 0 | 45 | 35 | 20 | 0 | 0 | 0 .2+| *800*
6+^| _260_ 2+^| _110_ 4+^| _330_ 6+^| _100_
.2+| <<AlgoClassmt61,61>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 10 | 80 | 150 | 100 | 50 | 45 | 45 | 15 | 25 | 45 | 20 .2+| *945*
6+^| _260_ 2+^| _110_ 4+^| _380_ 6+^| _195_
.2+| <<AlgoClassmt49,49>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 10 | 80 | 150 | 100 | 0 | 45 | 50 | 20 | 0 | 0 | 0 .2+| *815*
6+^| _260_ 2+^| _110_ 4+^| _330_ 6+^| _115_
|===


=== 3.2 Catégorie : Efficacité

==== *_3.2.1 Méthodologie et critères de classement_*

===== 3.2.1.1 Critères généraux

|===
3+^| *CRITÈRES DE CLASSEMENT*
3+^| _CATÉGORIE_ *_EFFICACITÉ_*
3+|
| *ID* | *CRITÈRE* | *MAXIMUM POINTS ATTRIBUÉS*
3+|
3+^| *_CONTENU_*
| C1 | Le programme comporte une méthode `RLE()`. | 50 pts
| C2 | Le programme comporte une méthode `RLE()` itérative / récursive. | 50 pts
| C3 | Le programme comporte une méthode `unRLE()`. | 50 pts
| C4 | Le programme comporte une méthode `unRLE()` itérative / récursive. | 50 pts
| C5 | Le programme ne définit pas de méthode principale (méthode `main()`). | 20 pts
| C6 | Les signatures des méthodes respectent les règles de nommage imposées (`RLE`, `RLERecursif`, `unRLE`, `unRLERecursif`, ou noms similaires). | 40 pts
2+| _TOTAL POINTS CONTENU_ | _260 pts_
3+|
3+^| *_EXÉCUTION_*
| E1 | Le programme compile et s'exécute. | 100 pts
2+| _TOTAL POINTS EXÉCUTION_ | _100 pts_
3+|
3+^| *_FONCTIONNEMENT_*
| F1 | Le type de retour des méthodes de compression / décompression est une chaîne de caractères. | 80 pts
| F2 | Le programme produit les résultats attendus. | 150 pts
| F3 | Le programme passe les tests unitaires avec succès. | 100 pts
| F4 | Le programme traite l'ensemble des cas d'erreurs (levées d'exceptions ou aucun plantage). | 10 pts
2+| _TOTAL POINTS FONCTIONNEMENT_ | _340 pts_
3+|
3+^| *_EFFICACITÉ_*
| EF1 | Complexité algorithmique (cf. <<RefComplexiteIPoints,Référentiel Complexité / Points>>). | 100 pts
| EF2 | Complexité en espace mémoire. | 50 pts
| EF3 | Temps d'exécution (cf. <<RefTempsExecIPoints,Référentiel Temps d'Exécution / Points>>). | 100 pts
2+| _TOTAL POINTS EFFICACITÉ_ | _250 pts_
3+|
3+^| *_QUALITÉ DE CODE_*
| Q1 | Indice de qualité de code selon les critères de *_Codacy_* (cf. <<RefQueliteIPoints,Référentiel Qualité de Code / Points>>). | 40 pts
| Q2 | Le programme fourni comporte des commentaires clairs et utiles. | 10 pts
2+| _TOTAL POINTS QUALITÉ DE CODE_ | _50 pts_
3+|
2+| *_TOTAL POINTS_* | *_1000 pts_*
3+|
3+^| *Remarque*
3+| Les critères de classement décrits ci-dessus s'appliquent uniquement aux algorithmes coucourant dans la catégorie *_Efficacité_*.
|===

===== 3.2.1.2 Méthodologie de mesure du temps d'exécution d'un algorithme

====== *Modalités de test*
Un test est définit par une longueur / taille de chaîne d'entrée (0, 10, 100 et 1000 caractères) et un nombre d'itération (1, 10, 25 et 50) de l'exécution de l'algorithme évalué (cf. méthode `RLE` itérative / récursive).

Afin de détemriner si les algorithmes évalués présentent des temps d'exécution différents en fonction de la structure de la chaîne de caractères en entrée, deux types de chaînes sont utilisées dans le cadre des tests :

Chaîne Aléatoire *Simple*::
    Chaîne de caractères générée pseudo-aléatoirement.

Chaîne Aléatoire Avec Répétitions Forcées::
    Chaîne de caractères comportant des suites, soit des répétitions, d'un même caractère.

====== *Modalités de mesure des temps d'exécution*
Les temps d'exécution indiqués dans le présent relevé correspondent aux *Temps d'Exécution Moyens* des algorithmes dans une situation de test définie, soit pour une longueur de chaîne d'entrée et un nombre d'itérations donnés.

Chaque test pour lequel le nombre d'itération est compris entre 1 et 25 inclus est exécuté 100 fois. Le temps d'exécution moyen d'un algorithme dans une situation de test donnée correspond donc à la moyenne des 100 temps d'exécution relevés à l'issue des 100 exécutions du test.

Lorsque le nombre d'itération testé est supérieur à 25 (ex : 50), le test n'est effecuté qu'une seule fois afin d'éviter un éventuel plantage de la machine sur laquel sont effecutés les test (temps d'exécution trop long, dépassement de la mémoire disponible... etc.). Ainsi, le temps d'exécution moyen de l'algorithme évalué est équivalent au temps d'exécution relevé à l'issue de l'unique test réalisé.

====== *Modalités de comparaison des temps relevés*
L'efficacité des algorithmes est évaluée par comparaison des *Temps Totaux Cumulés*, calculés à partir de la somme de l'ensemble des temps d'exécution relevé pour un algorithme. Le programme dont le Temps Total Cumulé est le plus faible est donc considéré comme étant l'algorithme le plus efficace / rapide.

===== 3.2.1.3 Référentiel d'évaluation de la complexité d'un algorithme

|===
4+^| *RÉFÉRENTIEL COMPLEXITÉ / POINTS* [[RefComplexiteIPoints]]
4+|
.2+| *Θ (THÊTA)*    .2+| *COMPLEXITÉ*   2+| *POINTS ÉQUIVALENTS*
^| / 100 ^| / 50
| Θ(1)                 | Constante      | 100 pts | 50 pts
| Θ(log(n))            | Logarithmique  | 90 pts  | 45 pts
| Θ(n)                 | Linéaire       | 70 pts  | 35 pts
| Θ(2n)                | --             | 60 pts  | 30 pts
| Θ(n log(n))          | Quasi-Linéaire | 60 pts  | 30 pts
| Θ(n^2)               | Quadratique    | 40 pts  | 20 pts
| Θ(n^k) _avec k fixé_ | Polynomiale    | 20 pts  | 10 pts
| Θ(k^n) _avec k fixé_ | Exponentielle  | 10 pts  | 5 pts
|===

===== 3.2.1.4 Référentiel d'évaluation du temps d'exécution d'un algorithme

|===
2+^| *RÉFÉRENTIEL TEMPS D'EXÉCUTION / POINTS* [[RefTempsExecIPoints]]
2+|
| *PLAGE DE TEMPS*       | *POINTS ÉQUIVALENTS*
| 29 000 ms -- 29 499 ms | 100 pts
| 29 500 ms -- 29 999 ms | 95 pts
| 30 000 ms -- 30 499 ms | 90 pts
| 30 500 ms -- 30 999 ms | 85 pts
| 31 000 ms -- 31 499 ms | 80 pts
| 31 500 ms -- 31 999 ms | 75 pts
| 32 000 ms -- 32 499 ms | 70 pts
| 32 500 ms -- 32 999 ms | 65 pts
| 33 000 ms -- 33 499 ms | 60 pts
| 33 500 ms -- 33 999 ms | 55 pts
2+|
| *[HC]*                 | 0 pts
|===

===== 3.2.1.5 Référentiel d'évaluation de la qualité d'un algorithme (Codacy)

|===
8+^| *RÉFÉRENTIEL QUALITÉ DE CODE / POINTS* [[RefQualiteIPoints]]
8+|
2+| *PROBLÈMES*  .13+| 2+| *COMPLEXITÉ* .13+| 2+| *DUPLICATION*
2+| _ISSUES_       2+| _COMPLEXITY_       2+| _DUPLICATION_
| 0   | 20 pts       | --  | --             | 0  | 10 pts
| 1   | 18 pts       | 1   | 10 pts         | 1  | 8 pts
| 2   | 16 pts       | 2   | 9 pts          | 2  | 6 pts
| 3   | 14 pts       | 3   | 8 pts          | 3  | 4 pts
| 4   | 12 pts       | 4   | 7 pts          | 4  | 2 pts
| 5   | 10 pts       | 5   | 6 pts          | 5+ | 0 pts
| 6   | 8 pts        | 6   | 5 pts          | -- | --
| 7   | 6 pts        | 7   | 4 pts          | -- | --
| 8   | 4 pts        | 8   | 3 pts          | -- | --
| 9   | 2 pts        | 9   | 2 pts          | -- | --
| 10+ | 0 pts        | 10+ | 1 pts          | -- | --
|===

==== *_3.2.2 Classement obtenu_*

===== 3.2.2.1 Classement général

|===
9+^| *CLASSEMENT*
9+^| _CATÉGORIE_ *_EFFICACITÉ_*
9+|
| *RANG* .6+| | *NUMÉRO*            | *PROGRAMME*                            | *LANGAGE* .6+| | *TOTAL POINTS* | *NOTE ÉQUIVALENTE* | *NOTE ARRONDIE AU PLUS PROCHE*
| *_1_*       | 21[[AlgoClassmt21]] | {21efficacite_java}[21efficacite.java] | `Java`         | 930 / 1000     | 18.60 / 20.00      | 18.50 / 20.00
| *_2_*       | 63[[AlgoClassmt63]] | {63efficacite_java}[63efficacite.java]   | `Java`         | 904 / 1000     | 18.08 / 20.00      | 18.00 / 20.00
| *_3_*       | 57[[AlgoClassmt57]] | {57efficacite_java}[57efficacite.java] | `Java`         | 823 / 1000     | 16.46 / 20.00      | 16.50 / 20.00
| 4           | 18[[AlgoClassmt18]] | {18efficacite_java}[18efficacite.java] | `Java`         | 781 / 1000     | 15.62 / 20.00      | 15.50 / 20.00
| 5           | 35[[AlgoClassmt35]] | {35efficacite_py}[35efficacite.py]     | `Python`       | 515 / 1000     | 10.30 / 20.00      | 10.25 / 20.00
|===

---

|===
18+^| *DÉTAIL DU CLASSEMENT*
18+^| _CATÉGORIE_ *_EFFICACITÉ_*
18+|
18+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
18+|
.3+| *N°* 16+| *POINTS PAR CRITÈRES DE CLASSEMENT* .3+| *TOTAL POINTS*
6+| CONTENU 1+| EXÉCUTION 4+| FONCTIONNEMENT 3+| EFFICACITÉ 2+| QUALITÉ
| C1 | C2 | C3 | C4 | C5 | C6 | E1 | F1 | F2 | F3 | F4 | EF1 | EF2 | EF3 | Q1 | Q2
.2+| <<AlgoClassmt18,18>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 0 | 0 | 70 | 30 | 60 | 31 | 0 .2+| *781*
6+^| _260_ 1+^| _100_ 4+^| _230_ 3+^| _160_ 2+^| _31_
.2+| <<AlgoClassmt21,21>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 10 | 70 | 30 | 100 | 30 | 0 .2+| *930*
6+^| _260_ 1+^| _100_ 4+^| _340_ 3+^| _200_ 2+^| _30_
.2+| <<AlgoClassmt57,57>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 0 | 0 | 70 | 30 | 95 | 28 | 10 .2+| *823*
6+^| _260_ 1+^| _100_ 4+^| _230_ 3+^| _195_ 2+^| _38_
.2+| <<AlgoClassmt63,63>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 0 | 70 | 30 | 80 | 32 | 2 .2+| *904*
6+^| _260_ 1+^| _100_ 4+^| _330_ 3+^| _180_ 2+^| _34_
.2+| <<AlgoClassmt35,35>> | 50 | 0 | 0 | 0 | 0 | 0 | 100 | 80 | 150 | 0 | 0 | 70 | 30 | 0 | 33 | 2 .2+| *515*
6+^| _50_ 1+^| _100_ 4+^| _230_ 3+^| _100_ 2+^| _35_
|===

===== 3.2.2.2 Détail de l'évaluation de la complexité des algorithmes

|===
4+^| *ÉVALUATION DE LA COMPLEXITÉ DES ALGORITHMES* [[TabEvalComplexite]]
4+^| MÉTHODE `RLE()` UNIQUEMENT
4+| 
4+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
4+|
.2+| *N°* | *COMPLEXITÉ ALGORITHMIQUE* | *COMPLEXITÉ EN ESPACE MÉMOIRE* .2+| *EXPLICATIONS*
2+| Soit `n` la longueur de la chaîne d'entrée.
| <<AlgoClassmt18,18>> | `Θ(n)` | `Θ(2n)` .5+| 
• La boucle principale a une complexité de `Θ(n)`. +
• Les opérations internes et externes (comparaisons, incrémentations, modifications de chaîne, réinitialisations de variables, etc.) sont toutes de complexité constante, soit de `Θ(1)`. +
• Dans le pire des cas, soit si tous les caractères de la chaîne d'entrée sont distincts deux à deux, la taille du StringBuilder (`Java`) / de la liste (`Python`) utilisé(e) pour construire la chaîne de caractères retournée est de `2n` caractères, ce qui équivaut donc à une complexité de `Θ(2n)`.
| <<AlgoClassmt21,21>> | `Θ(n)` | `Θ(2n)`
| <<AlgoClassmt57,57>> | `Θ(n)` | `Θ(2n)`
| <<AlgoClassmt63,63>> | `Θ(n)` | `Θ(2n)`
| <<AlgoClassmt35,35>> | `Θ(n)` | `Θ(2n)`
|===

===== 3.2.2.3 Détail de l'évaluation des temps d'exécution des algorithmes

|===
11+^| *RELEVÉ DES TEMPS D'EXÉCUTION EN MILLISECONDES (MS) DES ALGORITHMES* [[TabEvalTempsExec]]
11+^| MÉTHODES `RLE()` SIMPLE ET `RLE()` ITÉRATIVE / RÉCURSIVE UNIQUEMENT
11+| 
11+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
11+|
.3+| *N°* .3+| *IT.* 4+| *CHAÎNES ALÉATOIRES SIMPLES* 3+| *CHAÎNES ALÉATOIRES AVEC RÉPÉTITIONS FORCÉES* .3+| *TEMPS CUMULÉ / IT.* .3+| *TEMPS TOTAL CUMULÉ*
7+^| LONGUEUR CHAÎNE / NOMBRE DE CARACTÈRES (c) CONTENUS
| *_0 c_* | *_10 c_* | *_100 c_* | *_1000 c_* | *_10 c_* | *_100 c_* | *_1000 c_*
.4+| <<AlgoClassmt18,18>> | *_1_* | 0.000 | 0.001 | 0.006 | 0.056 | 0.005 | 0.014 | 0.070 | _0.152_ .4+| *_33055.464_*
| *_10_* | 0.000 | 0.010 | 0.094 | 0.878 | 0.041 | 0.319 | 0.909 | _2.251_
| *_25_* | 0.000 | 0.474 | 4.322 | 40.674 | 0.503 | 4.048 | 34.895 | _84.916_
| *_50_* | 0.001 | 362.777 | 3320.242 | -- | 353.421 | 3051.103 | 28880.601 | _32968.145_
.4+| <<AlgoClassmt21,21>> | *_1_* | 0.000 | 0.001 | 0.005 | 0.043 | 0.006 | 0.017 | 0.056 | _0.128_ .4+| *_29010.014_*
| *_10_* | 0.000 | 0.009 | 0.077 | 0.675 | 0.043 | 0.255 | 0.851 | _1.910_
| *_25_* | 0.000 | 0.381 | 3.369 | 33.006 | 0.382 | 3.271 | 28.383 | _68.792_
| *_50_* | 0.001 | 304.208 | 2714.328 | -- | 299.045 | 2558.253 | 23063.349 | _28939.184_
.4+| <<AlgoClassmt57,57>> | *_1_* | 0.000 | 0.007 | 0.016 | 0.075 | 0.001 | 0.005 | 0.049 | _0.153_ .4+| *_29919.97_*
| *_10_* | 0.000 | 0.038 | 0.264 | 0.870 | 0.009 | 0.067 | 0.559 | _1.807_
| *_25_* | 0.000 | 0.388 | 3.678 | 33.440 | 0.398 | 3.094 | 27.844 | _68.842_
| *_50_* | 0.001 | 289.384 | 2842.790 | -- | 287.591 | 2450.316 | 23979.086 | _29849.168_
.4+| <<AlgoClassmt63,63>> | *_1_* | 0.002 | 0.004 | 0.017 | 0.071 | 0.001 | 0.005 | 0.044 | _0.144_ .4+| *_31108.062_*
| *_10_* | 0.001 | 0.036 | 0.326 | 0.825 | 0.011 | 0.081 | 0.692 | _1.972_
| *_25_* | 0.001 | 0.470 | 3.979 | 35.131 | 0.413 | 3.175 | 29.341 | _72.510_
| *_50_* | 0.001 | 322.818 | 3002.029 | -- | 302.217 | 2545.690 | 24860.681 | _31033.436_
.4+| <<AlgoClassmt35,35>> | *_1_* | 0.001 | 0.006 | 0.043 | 0.456 | 0.005 | 0.039 | 0.377 | _0.927_ .4+| *_[HC]_*
| *_10_* | 0.002 | 0.300 | 2.889 | 27.463 | 0.293 | 2.414 | 22.233 | _55.594_
| *_25_* | 0.003 | 19.875 | 170.564 | 1664.110 | 18.462 | 147.311 | 1398.563 | _3418.888_
| *_50_* | 0.037 | 12827.669 | *_[HC]_* | *_[HC]_* | 12733.844 | *_[HC]_* | *_[HC]_* | *_[HC]_*
|===

===== 3.2.2.4 Détail de l'évaluation de la qualité des algorithmes

|===
6+^| *ÉVALUATION DE LA QUALITÉ DES ALGORITHMES* [[TabEvalQualite]]
6+^| CRITÈRES ÉTABLIS PAR *_CODACY_*
6+| 
6+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
6+|
| *N°* 1+| | *PROBLÈMES* | *COMPLEXITÉ* | *DUPLICATION* | *INDICE DE QUALITÉ*
.2+| <<AlgoClassmt18,18>> | _INDICATEURS_ | 2 | 6 | 0 .2+| *31 / 40*
| _POINTS ÉQUIVALENTS_ | 16 pts | 5 pts | 10 pts
.2+| <<AlgoClassmt21,21>> | _INDICATEURS_ | 2 | 7 | 0 .2+| *30 / 40*
| _POINTS ÉQUIVALENTS_ | 16 pts | 4 pts | 10 pts
.2+| <<AlgoClassmt57,57>> | _INDICATEURS_ | 3 | 7 | 0 .2+| *28 / 40*
| _POINTS ÉQUIVALENTS_ | 14 pts | 4 pts | 10 pts
.2+| <<AlgoClassmt63,63>> | _INDICATEURS_ | 2 | 5 | 0 .2+| *32 / 40*
| _POINTS ÉQUIVALENTS_ | 16 pts | 6 pts | 10 pts
.2+| <<AlgoClassmt35,35>> | _INDICATEURS_ | 2 | 4 | 0 .2+| *33 / 40*
| _POINTS ÉQUIVALENTS_ | 16 pts | 7 pts | 10 pts
|===


=== 3.3 Catégorie : Sobriété

==== *_3.3.1 Méthodologie et critères de classement_*

===== 3.3.1.1 Critères généraux

|===
3+^| *CRITÈRES DE CLASSEMENT*
3+^| _CATÉGORIE_ *_SOBRIÉTÉ_*
3+|
| *ID* | *CRITÈRE* | *MAXIMUM POINTS ATTRIBUÉS*
3+|
3+^| *_CONTENU_*
| C1 | Le programme comporte une méthode `RLE()`. | 50 pts
| C2 | Le programme comporte une méthode `RLE()` itérative / récursive. | 50 pts
| C3 | Le programme comporte une méthode `unRLE()`. | 50 pts
| C4 | Le programme comporte une méthode `unRLE()` itérative / récursive. | 50 pts
| C5 | Le programme ne définit pas de méthode principale (méthode `main()`). | 20 pts
| C6 | Les signatures des méthodes respectent les règles de nommage imposées (`RLE`, `RLERecursif`, `unRLE`, `unRLERecursif`, ou noms similaires). | 40 pts
2+| _TOTAL POINTS CONTENU_ | _260 pts_
3+|
3+^| *_EXÉCUTION_*
| E1 | Le programme compile et s'exécute. | 100 pts
2+| _TOTAL POINTS EXÉCUTION_ | _100 pts_
3+|
3+^| *_FONCTIONNEMENT_*
| F1 | Le type de retour des méthodes de compression / décompression est une chaîne de caractères. | 80 pts
| F2 | Le programme produit les résultats attendus. | 150 pts
| F3 | Le programme passe les tests unitaires avec succès. | 100 pts
| F4 | Le programme traite l'ensemble des cas d'erreurs (levées d'exceptions ou aucun plantage). | 10 pts
2+| _TOTAL POINTS FONCTIONNEMENT_ | _340 pts_
3+|
3+^| *_SOBRIÉTÉ NUMÉRIQUE_*
| SN1 | Consommation électrique du processeur (cf. <<RefConsoCPUIPoints,Référentiel Consommation Électrique Processeur / Points>>). | 150 pts
| SN2 | Consommation mémoire (cf. <<RefConsoMemoIPoints,Référentiel Consommation Mémoire / Points>>). | 80 pts
| SN3 | Taille du fichier contenant le programme (cf. <<RefTailleFichIPoints,Référentiel Taille Fichier / Points>>). | 20 pts
| SN4 | Indice de qualité de code selon les critères de *_Codacy_* (cf. <<RefQualiteIPointsSobriete,Référentiel Qualité de Code / Points>>). | 50 pts
2+| _TOTAL POINTS SOBRIÉTÉ NUMÉRIQUE_ | _300 pts_
3+|
2+| *_TOTAL POINTS_* | *_1000 pts_*
3+|
3+^| *Remarque*
3+| Les critères de classement décrits ci-dessus s'appliquent uniquement aux algorithmes coucourant dans la catégorie *_Sobriété_*.
|===

===== 3.3.1.2 Référentiel d'évaluation de la consommation du processeur par un algorithme

|===
2+^| *RÉFÉRENTIEL CONSOMMATION ÉLECTRIQUE PROCESSEUR / POINTS* [[RefConsoCPUIPoints]]
2+|
| *PLAGE DE PUISSANCE* | *POINTS ÉQUIVALENTS*
| 26.00 W -- 26.49 W   | 150 pts
| 26.50 W -- 26.99 W   | 125 pts
| 27.00 W -- 27.49 W   | 100 pts
| 27.50 W -- 27.99 W   | 75 pts
| 28.00 W -- 28.49 W   | 50 pts
| 28.50 W -- 28.99 W   | 25 pts
2+|
| *[HC]*               | 0 pts
|===

===== 3.3.1.3 Référentiel d'évaluation de la consommation mémoire d'un algorithme

|===
2+^| *RÉFÉRENTIEL CONSOMMATION MÉMOIRE / POINTS* [[RefConsoMemoIPoints]]
2+|
| *PLAGE D'ESPACE MÉMOIRE* | *POINTS ÉQUIVALENTS*
| 2000 Ko -- 2499 Ko       | 80 pts
| 2500 Ko -- 2999 Ko       | 60 pts
| 3000 Ko -- 3499 Ko       | 40 pts
| 3500 Ko -- 3999 Ko       | 20 pts
2+|
| *[HC]*                   | 0 pts
|===

===== 3.3.1.4 Référentiel d'évaluation de la taille d'un algorithme

|===
2+^| *RÉFÉRENTIEL TAILLE FICHIER / POINTS* [[RefTailleFichIPoints]]
2+|
| *TAILLE / POIDS FICHIER* | *POINTS ÉQUIVALENTS*
| 1 Ko                     | 20 pts
| 2 Ko                     | 15 pts
| 3 Ko                     | 10 pts
| 4 Ko                     | 5 pts
| 5+ Ko                    | 0 pts
|===

===== 3.3.1.5 Référentiel d'évaluation de la qualité d'un algorithme (Codacy)

|===
8+^| *RÉFÉRENTIEL QUALITÉ DE CODE / POINTS* [[RefQualiteIPointsSobriete]]
8+|
2+| *PROBLÈMES*  .13+| 2+| *COMPLEXITÉ* .13+| 2+| *DUPLICATION*
2+| _ISSUES_       2+| _COMPLEXITY_       2+| _DUPLICATION_
| 0   | 20 pts       | --  | --             | 0  | 10 pts
| 1   | 18 pts       | 1   | 20 pts         | 1  | 8 pts
| 2   | 16 pts       | 2   | 18 pts         | 2  | 6 pts
| 3   | 14 pts       | 3   | 16 pts         | 3  | 4 pts
| 4   | 12 pts       | 4   | 14 pts         | 4  | 2 pts
| 5   | 10 pts       | 5   | 12 pts         | 5+ | 0 pts
| 6   | 8 pts        | 6   | 10 pts         | -- | --
| 7   | 6 pts        | 7   | 8 pts          | -- | --
| 8   | 4 pts        | 8   | 6 pts          | -- | --
| 9   | 2 pts        | 9   | 4 pts          | -- | --
| 10+ | 0 pts        | 10+ | 2 pts          | -- | --
|===

==== *_3.3.2 Classement obtenu_*

===== 3.3.2.1 Classement général

|===
9+^| *CLASSEMENT*
9+^| _CATÉGORIE_ *_SOBRIÉTÉ_*
9+|
| *RANG* .6+| | *NUMÉRO*            | *PROGRAMME*                        | *LANGAGE* .6+| | *TOTAL POINTS* | *NOTE ÉQUIVALENTE* | *NOTE ARRONDIE AU PLUS PROCHE*
| *_1_*       | 25[[AlgoClassmt25]] | {25sobriete_java}[25sobriete.java] | `Java`         | 960 / 1000     | 19.20 / 20.00      | 19.25 / 20.00
| *_2_*       | 66[[AlgoClassmt66]] | {66sobriete_java}[66sobriete.java] | `Java`         | 903 / 1000     | 18.06 / 20.00      | 18.00 / 20.00
| *_3_*       | 12[[AlgoClassmt12]] | {12sobriete_java}[12sobriete.java] | `Java`         | 880 / 1000     | 17.60 / 20.00      | 17.50 / 20.00
| *_3_*       | 58[[AlgoClassmt58]] | {58sobriete_java}[58sobriete.java] | `Java`         | 879 / 1000     | 17.58 / 20.00      | 17.50 / 20.00
|===

---

|===
17+^| *DÉTAIL DU CLASSEMENT*
17+^| _CATÉGORIE_ *_SOBRIÉTÉ_*
17+|
17+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
17+|
.3+| *NUM.* 15+| *POINTS PAR CRITÈRES DE CLASSEMENT* .3+| *TOTAL POINTS*
6+| CONTENU 1+| EXÉCUTION 4+| FONCTIONNEMENT 4+| SOBRIÉTÉ NUMÉRIQUE
| C1 | C2 | C3 | C4 | C5 | C6 | E1 | F1 | F2 | F3 | F4 | SN1 | SN2 | SN3 | SN4 
.2+| <<AlgoClassmt12,12>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 0 | 125 | 20 | 15 | 30 .2+| *880*
6+^| _260_ 1+^| _100_ 4+^| _330_ 4+^| _190_
.2+| <<AlgoClassmt25,25>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 0 | 150 | 80 | 10 | 30 .2+| *960*
6+^| _260_ 1+^| _100_ 4+^| _330_ 4+^| _270_
.2+| <<AlgoClassmt58,58>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 10 | 50 | 80 | 15 | 34 .2+| *879*
6+^| _260_ 1+^| _100_ 4+^| _340_ 4+^| _179_
.2+| <<AlgoClassmt66,66>> | 50 | 50 | 50 | 50 | 20 | 40 | 100 | 80 | 150 | 100 | 0 | 75 | 80 | 20 | 38 .2+| *903*
6+^| _260_ 1+^| _100_ 4+^| _330_ 4+^| _213_
|===

===== 3.3.2.2 Détail de l'évaluation de la consommation du processeur par les algorithmes

|===
10+^| *ÉVALUATION DE LA CONSOMMATION DU PROCESSEUR PAR LES ALGORITHMES EN WATTS (W)*
10+^| MÉTHODES `RLE()` SIMPLE ET `RLE()` ITÉRATIVE / RÉCURSIVE 
10+| 
10+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
10+|
.2+| *NUMÉRO*             8+| *TEMPS EN SECONDES APRÈS LANCEMENT DU PROGRAMME DE TEST* .2+| *MOYENNE*
| *_0_* | *_1_* | *_2_* | *_3_* | *_4_* | *_5_* | *_6_* | *_+_*
| <<AlgoClassmt12,12>> | --    | 25.45 | 25.54 | 30.59 | 25.30 | 25.94 | 26.61 | --    | 26.57
| <<AlgoClassmt25,25>> | --    | 25.83 | 27.82 | 25.87 | 25.98 | 26.05 | 25.60 | --    | 26.19
| <<AlgoClassmt58,58>> | --    | 28.53 | 27.88 | 27.75 | 27.72 | 30.49 | 27.95 | --    | 28.38
| <<AlgoClassmt66,66>> | --    | 27.07 | 27.66 | 29.43 | 26.99 | 28.24 | 27.09 | --    | 27,74
|===

===== 3.3.2.3 Détail de l'évaluation de la consommation mémoire des algorithmes

|===
9+^| *ÉVALUATION DE LA CONSOMMATION MÉMOIRE DES ALGORITHMES EN KILO OCTETS (Ko)*
9+^| MÉTHODE `RLE()` UNIQUEMENT
9+| 
9+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
9+|
.2+| *N°* .2+| 6+|
*LONGUEUR DE LA CHAÎNE D'ENTRÉE* +
(EN NOMBRE DE CARACTÈRES)
.2+|
*ESPACE MÉMOIRE* +
*MOYEN OCCUPÉ*
| *_0_* | *_10_* | *_50_* | *_100_* | *_500_* | *_1000_* 
.3+| <<AlgoClassmt12,12>>
| *_Mémoire Totale Disponible_* | -- | 264192 | 264192 | 264192 | 264192 | 264192 .3+| *_3607_*
| *_Mémoire Libre_*             | -- | 261351 | 261351 | 261351 | 261107 | 260201
| *_Mémoire Occupée_*           | -- | 2841 | 2841 | 2841 | 3085 | 3991
.3+| <<AlgoClassmt25,25>>
| *_Mémoire Totale Disponible_* | -- | 264192 | 264192 | 264192 | 264192 | 264192 .3+| *_2389_*
| *_Mémoire Libre_*             | -- | 261803 | 261803 | 261803 | 261803 | 261803
| *_Mémoire Occupée_*           | -- | 2389 | 2389 | 2389 | 2389 | 2389
.3+| <<AlgoClassmt58,58>>
| *_Mémoire Totale Disponible_* | -- | 264192 | 264192 | 264192 | 264192 | 264192 .3+| *_2389_*
| *_Mémoire Libre_*             | -- | 261803 | 261803 | 261803 | 261803 | 261803
| *_Mémoire Occupée_*           | -- | 2389 | 2389 | 2389 | 2389 | 2389 
.3+| <<AlgoClassmt66,66>>
| *_Mémoire Totale Disponible_* | 264192 | 264192 | 264192 | 264192 | 264192 | 264192 .3+| *_2389_*
| *_Mémoire Libre_*             | 261803 | 261803 | 261803 | 261803 | 261803 | 261803
| *_Mémoire Occupée_*           | 2389 | 2389 | 2389 | 2389 | 2389 | 2389
|===

===== 3.3.2.4 Détail de l'évaluation de la qualité des algorithmes

|===
6+^| *ÉVALUATION DE LA QUALITÉ DES ALGORITHMES*
6+^| CRITÈRES ÉTABLIS PAR *_CODACY_*
6+| 
6+^| _PROGRAMMES TRIÉS PAR ORDRE D'ÉVALUATION_
6+|
| *N°* 1+| | *PROBLÈMES* | *COMPLEXITÉ* | *DUPLICATION* | *INDICE DE QUALITÉ*
.2+| <<AlgoClassmt12,12>> | *_INDICATEURS_* | 4 | 7 | 0 .2+| *30 / 50*
| *_POINTS ÉQUIVALENTS_* | 12 pts | 8 pts | 10 pts
.2+| <<AlgoClassmt25,25>> | *_INDICATEURS_* | 5 | 6 | 0 .2+| *30 / 50*
| *_POINTS ÉQUIVALENTS_* | 10 pts | 10 pts | 10 pts
.2+| <<AlgoClassmt58,58>> | *_INDICATEURS_* | 2 | 7 | 0 .2+| *34 / 50*
| *_POINTS ÉQUIVALENTS_* | 16 pts | 8 pts | 10 pts
.2+| <<AlgoClassmt66,66>> | *_INDICATEURS_* | 2 | 5 | 0 .2+| *38 / 50*
| *_POINTS ÉQUIVALENTS_* | 16 pts | 12 pts | 10 pts
|===




== *Annexes*

=== Notes er références

RLE : Run-Length Encoding.

*[HC]* : Hors Concours (dans le cadre de l'évaluation d'un critère donné).




---

[.text-center]
*Étudiant* +
Victor Jockin

[.text-center]
*Enseignants* +
Jean-Michel Bruel +
Yahn Formanczak

[.text-center]
*Formation* +
BUT Informatique +
1ère Année +
Promotion 2023-2024 +

[.text-center]
*Établissement* +
IUT de Blagnac, +
Université Toulouse II – Jean Jaurès (31)

---
